CLASS FEATURES
-In-class initializers for non-static data members
-Delegating constructors
-Inheriting constructors
-Default methods
-Deleted methods
-Override and final specifiers
-Extended friend declarations
-Nested class access rights
---------------------------

In-class initializers for non-static data members
class JetPlane
{
	public:
		string _mode1 = "Unknown";
		vector<Engine> _engines{Engine(), Engine()};
};

class JetPlane
{
	vector<Engine> _engines;
	string _manufacturer;
	string _model;
    public:
	JetPlane() :
	_engines(2), _manufacturer("Unknown"), _model("Unknown")
	{}

	JetPlan(const strng& manufacturer) :
	_engines(2), _manufacturer(manufacturer), _model("Unknown")
	{}
};

changes to

Class JetPlane
{
	vector<Engine> _engines {Engine(), Engine()};
	string _manufacturer = "Unknown";
	string _model = "Uknown";
    public:
    JetPlane()
    {}

    JetPlan(const string& manufacturer) : _manufacturer(manufacturer)
    {}
}; 
////////////
Class JetPlane
{
	string _manufacturer = "Unknown";
	string _model = "Uknown";
	vector<Engine> _engines {get_engine_count(_manufacturer, _mode1)};

	static size_t get_engine_count(const string& manufacturer, const string& mode1);
};

struct Counter
{
	int_count = 1;
};

Counter c = {10};
//compiler will complain about this

Class JetPlane
{
	public:
		vector<Engine> _engines{2}l
		JetPlan() : _engines(4)
		{}
};
 // number of engines will be 4 and not 2

--------------------------------
INHERITING CONSTRUCTORS

class Plane
{
	vector<Engine _engines;
	string _manufacturer;
	string _mode1;

	public:
		Plane(const string& manufacturer);
		Plane(const PlaneID& tail_number);
};

class JetPlane : public Plane
{
	public:
		//boring
		JetPlane(const string& manufacturer) : Plane(manufacturer)
		{}

		//boring
		JetPlan(const PlaneID& tail_number) : Plane(tail_number)
		{}
};

CHANGES TO

class JetPlane : public Plane
{
	using Plane::Plane;
};

JetPlan plane("Boeing"); // OK

class PropPlane : public Plane
{
	public:
		using Plane::Plane;

		//overrides Plane constructor with the same parameters
		PropPlan(const string* manufacturer) : Plane(manufacturer)
		{
		cout << "In PropPlan()" << endl;
		}
};

PropPlan prop_plane("ATR");
//////////////////

Class Plane
{
	string _manufacturer;

	public:
		Plane(const string& manufacturer) : _manufacturer(manufacturer)
		{}
};

class Boat
{
	string _boat_manufacturer;

	public:
		Boat(const string& manufacturer) : _boat_manufacturer(manufacturer)
		{}
};

class FloatPlane : public Plane, Public Boat
{
	using Plane::Plane;
	using Boat::Boat;

FloatPlane(const string& manufacturer) : Plane(manufacturer), Boat("n/a")
{}
};
/////////////

Inheriting Constructors
class PropPlane : public Plane
{
	size_t _prop_count;

	public:
		using Plane::Plane;
};

	//oops, _prop_count is not initialized
	PropPlane prop_Plane("ATR");
//////////////

DELEGATING CONSTRUCTORS

class JetPlane
{
	vector<Engine> _engines;
	string _manufacturer;
	string _model;

public:
	JetPlane() : _engines(2), _manufacturer("Unknown"), _model("Unknown")
	{
	configure_engines();
	}

	JetPlane(const string& manufacturer, const string& mode1) :
	_engines(Lookup::engine_count(manufacturer, mode1)),
	_manufacturer(manufacturer), _mode1(mode1)
	{
	configure_engines();
	assign_tail_number();
	}
	//...
};
/////////////

class JetPlane
{
	vector<Engine> _engines;
	string _manufacturer;
	string _model;

public:
	JetPlane() : JetPlan(2, "Unknown", "Unknown")
	{}

	JetPlane(const string& manufacturer, const string& mode1) :
	JetPlan(Lookup::engine_count(manufacturer,mode1), manufacturer, mode1)
	{
	assign_tail_number();
	}

private:
	JetPlane(size_t engine_count, const string& manufacturer, const string& mode1) :
	_engines(engine_count), _manufacturer(manufacturer), _mode1(mode1)
	{
	configure_engines();
	}
//...

};
-------------------------

DEFAULT METHODS

class JetPlane
{
	public:
		JetPlan() = default;
		JetPlane(const(JetPlane& other);
		JetPlan(JetPlan&&) = default;
};

class JetPlane
{
	public:
		JetPlane() = default;

		virtua ~JetPlane() = default;

	protected:
		JetPlan(const JetPlan& other) default;
		JetPlane& operator = (const JetPlane&) = default;
};

--------------------------------

DELETED METHODS

class JetPlane
{
	public:
		JetPlane() = default;
		JetPlane(const JetPlane&) = delete;
		JetPlane& operator = (const JetPlane&) = delete;
		JetPlane(JetPlane&&) = default;
		JetPlane& operator = (JetPlane&&) = default;
};
	-allows you to disable some instantiations of a template

	template<typename t>
	void serialize(const T& obj)
	{
		cout << obj.to_string();
	};

	//PasswordStore not allowed to be serialized
	void serialize(const PasswordStore&) = delete;
		
	-allows you to disable unwanted conversion

	class Altimeter
	{
	public:
		Altimeter(double){}
		Altimeter(int) = delete;
	};
	
	-allows you to disable heap allocation

	class StackOnly
	{
	public:
		void* operator new(size_t) = delete;
	};

-------------------------------------

OVERRIDE AND FINAL

int override = 5; //ok
int final = 10; // ok

struct Base
{
	virtual void f(int)
	{}
};

struct Dervied: public Base
{
	virtual void f(int) override //ok
	{}

	virtual void f(double) override // error
	{}
};

/////

struct Base final
{};

struct Derived : public Base //compile error, can't inherit from final class
{};

struct Interface
{
	virtual void f()
	{}
};

struct Base : public Interface
{
	virtual void f() final
	{}
};

struct Derived : public Base
{
	virtual void f() // compile error, can't override a final method
	{}
};
--------------------------

EXTENDED FRIEND DECLARATIONS
