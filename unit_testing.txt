UNIT TESTING
unit test - is another piece of code that verifies my code. usually a method to check and see that the code does what it is intended to do. Tests a specific functionality. Should have a clear pass or fail criteria. Should run in isolation  - should not contain external component outside of my control.

Simple Unit Test
TEST_CLASS(MyUnitTest)
{
	public:
		TEST_METHOD(TestMethod1)
		{
			//your test code here.
		}
}

-----

Why Write Automated Tests?
-Quick feedback about your code.
-Avoid bugs.
-Immune to regression.
-Change your code without fear.
-In code documentation
-You're already testing your code.

-----

ARRANGE - where I set up everything I need for the test.
ACT - where you run the actual test.
ASSERT - where I check what the test did.

-----

Why do we need a good test name?
-Understand what the test does
-Execute a subset of your tests
-Find the test you need
-Failures help root cause analysis
-A good test name will help you write a good test

Good names include-
-Express a specific requirement/behavior
-Should include:
	-The starting state
	-given input
	-expected result
	-unless irrelevant

-Should be easily found

-Should not include "Test"

Good unit test name examples are
-If Age >18 IsAdult returns true
-When called with xyz then return true
-Should throw exception When invalid user
-Given authenticated When invalid number used Then transaction will fail
-Called with empty list -->> return nullptr

----

Test Name Related Arguments
-Run Specific Tests
     thisTest
     "This Test"

-Run Group of Test
     Customer*
     *Customer

-Run all tests except
     Exclude:otherTest
     ~otherTest~*other*

Mix commands
a* ~ab* ab

----

Tags
-A simple way to group tests
-Additional strings associated with test case
	    -Must begin with an alpha numeric character
-Tag names are not case sensitive
-Use to categorize tests
     -Use code under test(DB,Model,Customer)
     -By test type(Unit,Integration,Scenario)
     -By execution speed(Slow,Fast)

----

Special Tags
[!hide] or [.]	Skip/Ignore test
[.][integration]->[.integration]
[!throws]	Exclude if run catch with -e or --nothrow
[!shouldfail]	Reverse failing logic(pass if fail)
[!mayfail]	Does not fail the test if assertionfails
[#<filename>]	Use -# to specify filename as tag

----

Create Tag Alias
CATCH_REGISTER_TAG_ALIAS( "[@abc]","[a],[b]~[c]" )

----

More Command Line Arguments

-h, -?, --help
-f, --input file <filename>
-o, --out <filename>
-b, --break
-a, --abort
-x, --abortx[<threshold>]

----

ASSERTING USING CATCH

REQUIRE
-Single macro for all/most assertions needs
-Write the assertion in plain code
-Excellent failure messages

Why care about failure messages?
-understand why the test failed
-reduce debugging time
-it's the purpose of the test

The Problem with Multiple Assertions
-When it fails, you lose information about the rest of the calls
-Testing more than one aspect
-Create complicated tests

When to use Multiple Assertions?
-Multiple checks for single "concept"
-Checking related logic
-Always be pragmatic

REQUIRE and CHECK

-REQUIRE(2 + 2 == 5); //Abort test -->Test fail
-CHECK(2 + 2 == 5); //Continue test --> Test fail

-REQUIRE_FALSE(MethodReturnsFalse);
-CHECK_FALSE(MethodReturnsFalse);

Handling Multiple Assertions in One Test
-Split to multiple tests
-Use CHECK
-Override operator ==
-Compare Collections
-Use Multiple asserts

Asserting for Exceptions

-REQUIRE_THROWS(expression)
-CHECK_THROWS(expression)

-REQUIRE_THROWS_AS(expression, type)
-CHECK_THROWS_AS(expression, type)

-REQUIRE_NOTHROW(expression)
-CHECK_NOTHROW(expression)

Adding more information to test run
-INFO
-WARN
-FAIL
-CAPTURE

----

Simple information from complex types

class SomeClass
{
	public:
		int my_int_;
		double my_double_;
};

REQUIRE(result == expected);

----

STRING CONVERSIONS
-operator <<
-Catch::toString
-Catch::StringMaker specialisation
-CATCH_TRANSLATE_EXCEPTION

Operator << Overloading for std::ostream
ostream& operator << (ostream& os, MyType const& value)
{
	os << convert(value);
	return os;
}

Catch::toString Overload
namespace Catch
{
	string toString(MyType const& value)
	{
	return convert(value);
	}
}

Catch::StringMaker Specialisation
namespace Catch
{
	template<> struct StringMake<t>
	{
		static std::string convert(T const& value)
		{
			return convert(value);
		}
	};
}

Custom Exception Text
CATCH_TRANSLATE_EXCEPTION(MyType& ex)
{
	return ex.message();
}

----
