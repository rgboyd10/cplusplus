Overview
Template features
Class features
Overhauled syntax for initialization

Features
-Variadic templates - allow templates to take an arbitrary number of arguments.
-Template aliases - like type divs with partially-bound template parameters.
-Proper parsing of multiple closing angle brackets
-Local and unnamed types can be used as template arguments.
-Extern templates
-Default values for function template parameters.
-Arbitrary expressions in template deduction contexts.

Variadic templates
	 -function<bool(int, double)>
	 -function<int(double, double, double)>
	 -function<void(string, int, string, int, string, int)>

template<typename Strea, typename... Columns>
class CSVPrinter
{
	public:
		void output_line(const Columns&... columns);
		//other methods, constructors etc. not shown
};

... - used to indicate 0 or more occurrencies of something
Columns -  is a template parameter pack

	-What are variadic templates good for?
	      -Perform type computation at compile time
	      -Generate type structure.
	      -Implement type safe functions with arbitrary number of arguments
	      -Perform argument forwarding - used to perfect forwarding.

---------------------------
Working with Parameter Packs

void output_line(const Columns&... columns)
{
	write_line(validate(columns)...);
}

CSVPrinter<decltype(stream), int, double, string> printer;
is equal to
void output_line(const int& col1, const double& col2, const string& col3)
{
	write_line(validate(col1), validate(col2), validate(col3));
}

template<typename Value, typename... Values>
void write_line(const Value& val, const Values&...values) const
{
	write_column(val, _sep);
	write_line(values...);
}

template <typename Value>
void write_line(const Value &val) const
{
	write_column(val, "\n");
}

void output_line(const Columns&... columns);
